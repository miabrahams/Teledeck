// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package external

import (
	"image"
	"teledeck/internal/models"

	mock "github.com/stretchr/testify/mock"
)

// NewMockTaggingService creates a new instance of MockTaggingService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTaggingService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTaggingService {
	mock := &MockTaggingService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTaggingService is an autogenerated mock type for the TaggingService type
type MockTaggingService struct {
	mock.Mock
}

type MockTaggingService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTaggingService) EXPECT() *MockTaggingService_Expecter {
	return &MockTaggingService_Expecter{mock: &_m.Mock}
}

// TagImage provides a mock function for the type MockTaggingService
func (_mock *MockTaggingService) TagImage(imagePath string, cutoff float32) ([]models.TagWeight, error) {
	ret := _mock.Called(imagePath, cutoff)

	if len(ret) == 0 {
		panic("no return value specified for TagImage")
	}

	var r0 []models.TagWeight
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, float32) ([]models.TagWeight, error)); ok {
		return returnFunc(imagePath, cutoff)
	}
	if returnFunc, ok := ret.Get(0).(func(string, float32) []models.TagWeight); ok {
		r0 = returnFunc(imagePath, cutoff)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.TagWeight)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, float32) error); ok {
		r1 = returnFunc(imagePath, cutoff)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTaggingService_TagImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TagImage'
type MockTaggingService_TagImage_Call struct {
	*mock.Call
}

// TagImage is a helper method to define mock.On call
//   - imagePath string
//   - cutoff float32
func (_e *MockTaggingService_Expecter) TagImage(imagePath interface{}, cutoff interface{}) *MockTaggingService_TagImage_Call {
	return &MockTaggingService_TagImage_Call{Call: _e.mock.On("TagImage", imagePath, cutoff)}
}

func (_c *MockTaggingService_TagImage_Call) Run(run func(imagePath string, cutoff float32)) *MockTaggingService_TagImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 float32
		if args[1] != nil {
			arg1 = args[1].(float32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTaggingService_TagImage_Call) Return(tagWeights []models.TagWeight, err error) *MockTaggingService_TagImage_Call {
	_c.Call.Return(tagWeights, err)
	return _c
}

func (_c *MockTaggingService_TagImage_Call) RunAndReturn(run func(imagePath string, cutoff float32) ([]models.TagWeight, error)) *MockTaggingService_TagImage_Call {
	_c.Call.Return(run)
	return _c
}

// TagImageData provides a mock function for the type MockTaggingService
func (_mock *MockTaggingService) TagImageData(image1 image.Image, cutoff float32) ([]models.TagWeight, error) {
	ret := _mock.Called(image1, cutoff)

	if len(ret) == 0 {
		panic("no return value specified for TagImageData")
	}

	var r0 []models.TagWeight
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(image.Image, float32) ([]models.TagWeight, error)); ok {
		return returnFunc(image1, cutoff)
	}
	if returnFunc, ok := ret.Get(0).(func(image.Image, float32) []models.TagWeight); ok {
		r0 = returnFunc(image1, cutoff)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.TagWeight)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(image.Image, float32) error); ok {
		r1 = returnFunc(image1, cutoff)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTaggingService_TagImageData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TagImageData'
type MockTaggingService_TagImageData_Call struct {
	*mock.Call
}

// TagImageData is a helper method to define mock.On call
//   - image1 image.Image
//   - cutoff float32
func (_e *MockTaggingService_Expecter) TagImageData(image1 interface{}, cutoff interface{}) *MockTaggingService_TagImageData_Call {
	return &MockTaggingService_TagImageData_Call{Call: _e.mock.On("TagImageData", image1, cutoff)}
}

func (_c *MockTaggingService_TagImageData_Call) Run(run func(image1 image.Image, cutoff float32)) *MockTaggingService_TagImageData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 image.Image
		if args[0] != nil {
			arg0 = args[0].(image.Image)
		}
		var arg1 float32
		if args[1] != nil {
			arg1 = args[1].(float32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTaggingService_TagImageData_Call) Return(tagWeights []models.TagWeight, err error) *MockTaggingService_TagImageData_Call {
	_c.Call.Return(tagWeights, err)
	return _c
}

func (_c *MockTaggingService_TagImageData_Call) RunAndReturn(run func(image1 image.Image, cutoff float32) ([]models.TagWeight, error)) *MockTaggingService_TagImageData_Call {
	_c.Call.Return(run)
	return _c
}
